# -*- coding: utf-8 -*-
"""projeto-sr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CawBJ3k_f9gQ74WKgGZDxMGxtjbD8CIh

# **Projeto Pedido Sugerido Sephora**
## Modelo de Recomendação Baseado em Filtragem Colaborativa
## **Objetivos**: Recomendar produtos para os clientes, com base nas reviews de clientes com características físicas similares.

## **Dados**:


1.   Obtidos na fonte: **Kaggle**, via [link](https://www.kaggle.com/datasets/nadyinky/sephora-products-and-skincare-reviews).
2.   Conteúdo: Cadastro mestre de produtos (product_info.csv) e reviews de clientes por produto (reviews_0_250.csv).
3. Tratamento, limpeza e estruturação dos dados: Necessário.

Definir % considerado na avaliação como positivo/negativo.

## **Principais Atributos e Indicadores**: Clusterizar produtos por característica dos clientes e reviews.

## **Ações**: Cálculo das médias de avaliações dos produtos, separando em 2 grupos:
1. Produtos com avaliações positivas: Utilizar na recomendação.
2. Produtos com avaliações negativas: Não utilizar na recomendação, enviar para pesquisa de mercado para entendimento do que pode ser melhorado.

## **Benefícios**: Clientes terão mix de produtos sugeridos com base nas características de cada pessoa, beneficiando o cliente e empresa. (Dessa forma, não se perde recursos com marketing, ao mesmo tempo que consegue fidelizar clientes).

Importa bibliotecas
"""

import pandas as pd

"""Importa arquivo de cadastro de produtos"""

df_cadastro = pd.read_csv("product_info.csv")

"""Verifica informações no cadastro de produtos"""

df_cadastro.info()

min_rating = int(df_cadastro['rating'].min())
max_rating = int(df_cadastro['rating'].max())
count_id = df_cadastro['product_id'].count()

print("A menor avaliação de produto no cadastro da Sephora é: ",min_rating, "\nEnquanto a maior nota é: ", max_rating)

# Verifica quais são os produtos com avaliação mínima
df_cadastro.query("rating == {}".format(min_rating))['product_name']

count_min = df_cadastro.query("rating == {}".format(min_rating))["product_id"].count()
count_max = df_cadastro.query("rating == {}".format(max_rating))["product_id"].count()

print("Total de produtos avaliados com nota mínima: ",df_cadastro.query("rating == {}".format(min_rating))['product_id'].count(), "O que representa {}% do total".format(count_min/count_id))

print("Total de produtos avaliados com nota máxima: ",df_cadastro.query("rating == {}".format(max_rating))['product_id'].count(), "O que representa {}% do total".format(count_max/count_id))

"""Seleciona apenas as colunas que serão utilizadas"""

df_cadastro = df_cadastro[['product_id',  'primary_category', 'out_of_stock']]
df_cadastro

"""Importa arquivo de reviews"""

df_review = pd.read_csv("reviews_0_250.csv", low_memory=False)

df_review.head()

"""Verifica informações no arquivo de reviews

**N2 | A03 | 3.A**
"""

df_review.info()

"""Seleciona apenas as colunas que serão utilizadas"""

df_review = df_review[['rating', 'is_recommended','product_id', 'skin_tone','skin_type','hair_color', 'brand_name', 'product_name']]
df_review

"""**N2 | A03 | 3.B**"""

df_review = df_review.merge(df_cadastro, left_on='product_id', right_on='product_id')

df_review

# Filtra os produtos não recomendados
df_review_negativo = df_review.query("is_recommended == 0 & out_of_stock == 0")
df_review_negativo.head()

df_review_negativo['product_name'].drop_duplicates(keep='first')

# Filtra os produtos recomendados (apenas os produtos que tenham estoque)
df_review_positivo = df_review.query("is_recommended == 1 & out_of_stock == 0")
df_review_positivo.head()

# Quantidade de avaliações com os critérios selecionados
print("Total de avaliações positivas é", df_review_positivo['rating'].count())

"""**N2 | A03 | 3.C**


O comando *"low_memory=False"* executado na importação do arquivo já visa remover linhas fora do padrão do csv.

Os filtros necessários também foram aplicados, para utilizar somente os produtos que tem avaliação igual ou superior à 4, e é recomendado pelo user id.

**N2 | A03 | 3.D**
"""

# Média geral das avaliações de todos os produtos
df_media_geral = df_review["rating"].mean()
print(f'A avaliação média dos produtos Sephora é de {df_media_geral:,.2f}')

# TOP 10 Média das avaliações por marca e produto
df_review_positivo.groupby(["brand_name", "primary_category", "skin_type", "out_of_stock", "product_id", "product_name"])["rating"].mean().sort_values(ascending=False)[0:10]

# Cria df para armazenar a média de reviews
df_mean_review = pd.DataFrame(df_review_positivo.groupby(["brand_name", "primary_category", "skin_type", "out_of_stock", "product_id", "product_name"])["rating"].mean().sort_values(ascending=True))

df_mean_review = df_mean_review.rename(columns={'rating': 'rating_mean'})
df_mean_review

# Cria df para armazenar a contagem de reviews
df_count = pd.DataFrame(df_review_positivo.groupby(["brand_name", "primary_category", "skin_type", "out_of_stock", "product_id", "product_name"])["rating"].count().sort_values(ascending=True))

df_count = df_count.rename(columns={'rating': 'rating_count'})
df_count

# Merge dos dataframes para unificar as informações de quantidade e média de reviews
df_resumo = pd.merge(df_mean_review,df_count, on=['brand_name','primary_category', 'skin_type', 'out_of_stock','product_id', 'product_name'])
df_resumo.sort_values(by='rating_count',ascending=True)[0:10]

# Utilizando apenas as marcas que contenham acima de 100 avaliações, para remover casos de outliers
df_resumo = df_resumo.query("rating_count > 100")
df_resumo

# Ordena Por maior quantidade de avaliações, e melhor média de avaliações, e exibe as top 10 marcas
df_recomendacao = df_resumo.sort_values(['rating_mean', 'rating_count'], ascending=False)
df_recomendacao.head(10)

# Distinct das categorias
df_skin_type = df_review[["skin_type"]]
df_skin_type = df_skin_type.drop_duplicates(keep='first')

print("De acordo com o seu tipo de pele, escolha um para receber a sua recomendação: \n\n", df_skin_type)

skin = input("Para qual tipo de pele deseja sugestão? \n")

df_recomendacao = df_recomendacao.query("skin_type == '{}'".format(skin))

print("Aqui está a recomendação das top 10 marcas com mais reviews e melhores avaliações para o seu tipo de pele\n", df_recomendacao.head(10))

# Destaque da melhor avaliação x maior quantidade de avaliações
df_recomendacao.style\
  .set_caption("Melhor média e maior quantidade de avaliações")\
  .highlight_max()

# Gradiente de cores por melhor média e maior quandidade de avaliações
df_recomendacao.style\
  .set_caption("Melhor média x maior quantidade de avaliações")\
  .background_gradient()

import matplotlib.pyplot as plt

df_recomendacao.plot(x='rating_mean')
plt.title('Média de avaliações x contagem')

"""**N2 | A03 | 4.A** Pode-se realizar uma abordagem de recomendação por filtragem baseada em conteúdo? quais atributos serão a base?
Acredito que não, pois a filtragem baseada em conteúdo é mais utilizada para dados textuais, e o foco desse projeto será utilizar campos da avaliações não textuais (avaliações com notas de 0 a 5).

**N2 | A03 | 4.B** pode-se realizar uma abordagem de recomendação por filtragem colaborativa? Quais atributos serão a base?
Sim!! O conceito desse projeto baseia-se em filtragem colaborativa, uma vez que usaremos as avaliações de clientes com características similares para realizar a recomendação. Os atributos base serão as colunas "is_recommended" (onde o usuário especifica se recomenda o produto) e a coluna "rating" que é a nota atribuida na avaliação.

**N2 | A03 | 4.C** Há possibilidade de apresentar uma abordagem híbrida, que vai levar em consideração a filtragem baseada em conteúdo e filtragem colaborativa? De que forma?  Talvez sim, se formos levar em consideração a coluna "review_text" onde há o texto da avaliação do usuário, porém não seria o foco do projeto.
"""